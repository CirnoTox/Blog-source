---
title: OS_project源码结构说明
date: 2021-07-01 07:55:34
tags: OS_project
---
# 前言
自己太菜，别人课设早都完成了，今天的机房就我一个人，真是安静啊，只有键盘的敲击声和空调的白噪音。分部的介绍请见上一篇文章，本片将详细介绍下我操作系统课设的源码架构。最后也会贴一部分到课设报告上。

# 主函数
主函数主要由以下部分组成：
1. 初始化各个全局变量
2. 获取输入数据
3. 创建和join各个顾客与销售员线程
4. 输出数据
## 初始化的全局变量
全局变量有：全局剩余面包蛋糕`bread``cake`，顾客线程用于数据存入的互斥量`customerDataMutex`,用于确定一对顾客和销售者销售是否结束的互斥量`customerSaleFinishMutex`，条件变量`customerSaleFinishCV`，条件`customerIdSaleFinished`，以及销售者线程用于数据读取的互斥量`salerMutex`.
## 创建与合并线程
使用两个`vector<thread>`，可以将它们理解为动态可变的、类型为线程的数组。之后通过两个`for`循环创建线程，循环中对`vector<thread>`调用`emplace_back()`，理解为向数组末端添加数据，而这个添加的数据是`thread`，也就创建了线程，第二个参数代表给线程传入的参数。每创建完一个线程会等待极短的时间，保证后面顾客线程添加数据的顺序，创建完成后两个`for`对线程数组中的所有线程调用合并函数`join`。

# 顾客线程
1. 顾客生成数据并添加数据
2. 顾客线程等待条件变量成立后离开
## 生成添加数据
1. 上锁
2. 随机数生成数据
3. 向数据队列添加数据
4. 解锁
这部分内容在上一篇都基本讨论过了，就不再赘述

# 消费者线程
while(1)
{
    1. 等待随机一端时间模拟销售花费的时间
    2. 上锁（因为要从队列取数据了，保证互斥访问）
    3. 取数据，判断数据情况，对全局数据做操作
    4. 提醒顾客离开
    5. 解锁
}
## 提醒顾客离开
如果这里不是很有把握，可以对代码做些修改进行测试。比如，可以在从队列取出数据时，将`cake``bared``customerId`数据存入一个新的数组中，全部结束后，对数据重新进行计算，看看是不是符合规定。